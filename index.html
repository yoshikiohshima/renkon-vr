<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"> 
    </head>
    <body>
        <div id="renkon">
            <script type="reactive">
                const hostName = (() => {
                    const maybeHost = new URL(window.location).searchParams.get("host")
                    if (maybeHost) {
                        return maybeHost;
                    }
                    return "/";
                })();

                const {toBase64} = import("./media/toBase64.js");
                const localMediaModule = import("./media/localmedia.js");
                const {audioBufferToWav} = import("./media/wav.js");
                
                const {h, render, html} = import(Renkon.spaceURL("./preact.standalone.module.js"));
                const {ReflectCommands} = import(`${hostName}/tool-call/js/commands.js`);

                const audioContext = Behaviors.keep(Events.listener(document.querySelector("#logo"), "click", (evt) => new window.AudioContext()));

                const localMedia = new localMediaModule.LocalMedia({
                    videoSource: false,
                    onstreamchange: (stream) => {
                    }
                });

                const streams = localMedia.setup();

                const source = ((audioContext, localMedia, _streams) => {
                    console.log("in source", audioContext, localMedia);
                    return new window.MediaStreamAudioSourceNode(audioContext, {mediaStream: localMedia.stream})
                })(audioContext, localMedia, streams);

                const processor = ((audioContext) => {
                    return audioContext.audioWorklet.addModule(`../media/audio-samples.js`).then(() => {
                        const worklet = new window.AudioWorkletNode(audioContext, "processor");
                        worklet.addEventListener("processorerror", console.log);
                        return worklet;
                    })
                })(audioContext);

                const inputs = Events.observe((notifier) => {
                    processor.port.onmessage = (event) => {
                        notifier(event.data);
                    }
                    source.connect(processor);
                    return () => source.disconnect(processor);
                }, {queued: true});

                const voiceChunk = Events.receiver();

                console.log("voiceChunk", voiceChunk);

                const speaking = Behaviors.collect({time: 0, data: [], speaking: false}, inputs, ((old, current) => {
                    const max = Math.max(...current.map((c) => c.max));
                    const currentTime = current[current.length - 1].currentTime;
                    const newInput = current.map((c) => c.input);

                    if (old.speaking) {
                        const newData = [...old.data, ...newInput];
                        if (max < 0.01) {
                            if (currentTime > old.time + 0.5) {
                                Events.send(voiceChunk, {time: currentTime, data: newData});
                                return {time: currentTime, data: newData, speaking: false};
                            }
                            return {time: old.time, data: newData, speaking: old.speaking};
                        }
                        return {time: currentTime, data: newData, speaking: old.speaking};
                    }

                    if (max < 0.01) {
                        return old;
                    }

                    const newData = newInput;
                    return {time: currentTime, data: newInput, speaking: true};
                }));

                const toolCall = new ReflectCommands(hostName + "/tool-call").reflect();
                const root = new ReflectCommands(hostName + "/").reflect();
                const whisper = root["faster-whisper:transcribe-data"];

                const commandList = {
                    cursor_next_line: {
                        description: "Move the cursor to n lines down the current line",
                        meta: {
                            "#/data/parameters/nLines": {
                                type: "number",
                                description: "The amount of movement.",
                            },
                            "#/data/returns/ok": {
                                type: "boolean"
                            },
                        }
                    },
                    type_in: {
                        description: "Type in the argument at the current cursor position",
                        meta: {
                            "#/data/parameters/input": {
                                type: "string",
                                description: "The string to be entered."
                            },
                            "#/data/returns/ok": {type: "boolean"}
                        }
                    }
                };

                const commandResponse = ((toolCall, commandList, input) => {
                    console.log("toolCall", input);
                    const cmd = toolCall["suggest"];
                    if (!cmd) {return;}
                    return cmd.run({commands: commandList, input}).catch((e) => {
                        console.log("tool-call error: ", e);
                        return;
                    });
                })(toolCall, commandList, input);
                
                ((commandResponse) => {
                    console.log({commandResponse});
                    if (commandResponse?.choices[0]) {
                        const div = document.createElement("div");
                        const result = commandResponse?.choices[0];
                        const str = `${result.command}(${Object.keys(result.parameters).map((k) => result.parameters[k])})`;
                        div.textContent = str;
                        const br = document.createElement("br");
                        const renkon = document.querySelector("#renkon");
                        renkon.appendChild(div);
                        renkon.appendChild(br);
                    }
                })(commandResponse);

                const wav = ((voiceChunk) => {
                    const zip = (pairs) => {
                        const length = pairs[0][0].length * pairs.length;
                        const a = new Float32Array(length);
                        const b = new Float32Array(length);
                        let index = 0;
                        for (let i = 0; i < pairs.length; i++) {
                            a.set(pairs[i][0], index);
                            b.set(pairs[i][1], index);
                            index += pairs[i][0].length;
                        }
                        return [a, b];
                    }
                    return {timelabel: voiceChunk.time, wav: audioBufferToWav(44100, zip(voiceChunk.data))};
                })(voiceChunk);

                console.log("wav", wav);

                /*
                const saveWav = ((wav) => {
                    let div = document.createElement("a");
                    const blob = new Blob([wav.wav], {type: "audio/wav"});
                    let fileURL = URL.createObjectURL(blob);
                    div.setAttribute("href", fileURL);
                    div.setAttribute("download", `wav-${Date.now()}.wav`);
                    div.click();
                    })(wav);

               */

                const transcribed = ((wav, whisper) => {
                    const audio_data = toBase64(new Uint8Array(wav.wav));
                    const audio_metadata = {mime_type: "audio/wav"};
                    const task = "transcribe";
                    return whisper.run({audio_data, audio_metadata, task});
                })(wav, whisper);
                    
                console.log("transcribed", transcribed);

                const words = ((transcribed) => {
                    const result = [];
                    transcribed.segments.forEach((seg) => {
                        seg.words.forEach((word) => result.push(word.word));
                    });
                    return result.join(" ");
                    })(transcribed);

                const input = words;

                console.log("words", words);
            </script>
            <div id="logo">Start</div>
        </div>
        <script type="module">
            import {view, newInspector} from "./renkon.js";
            view({app: {newInspector}});
        </script>
    </body>
</html>
